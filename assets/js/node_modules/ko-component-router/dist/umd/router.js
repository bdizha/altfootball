(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "knockout", "./context", "./route", "./utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var ko = require("knockout");
    var context_1 = require("./context");
    var route_1 = require("./route");
    var utils_1 = require("./utils");
    /* eslint-enable */
    var Router = (function () {
        /* eslint-enable */
        function Router(url, $parentCtx, _with) {
            if (_with === void 0) { _with = {}; }
            this.onInit = [];
            this.component = ko.observable(null);
            this.isNavigating = ko.observable(true);
            this.isRoot = utils_1.isUndefined($parentCtx);
            this.routes = this.isRoot
                ? Router.createRoutes(Router.routes)
                : $parentCtx.route.children;
            if (this.isRoot) {
                Router.head = this;
                document.addEventListener(Router.events.click, Router.onclick);
                window.addEventListener(Router.events.popstate, Router.onpopstate);
            }
            this.ctx = new context_1.Context(this, $parentCtx, Router.getPath(url), _with);
        }
        Object.defineProperty(Router.prototype, "initialized", {
            get: function () {
                var _this = this;
                if (this.isNavigating()) {
                    return new Promise(function (resolve) { return _this.onInit.push(resolve); });
                }
                else {
                    return Promise.resolve(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Router.prototype.init = function () {
            var _this = this;
            this.isNavigating(false);
            this.ctx.runAfterRender().then(function () {
                var resolveRouter = function (router) { return function (resolve) { return resolve(router); }; };
                var ctx = _this.ctx;
                while (ctx) {
                    utils_1.map(ctx.router.onInit, resolveRouter(ctx.router));
                    ctx = ctx.$child;
                }
            });
        };
        Router.prototype.update = function (url, _args) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var args, fromCtx, _a, search, hash, path, route, _b, pathname, childPath, samePage, toCtx, shouldNavigate, _c, r, p;
                return tslib_1.__generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (utils_1.isBoolean(_args)) {
                                args = { push: _args };
                            }
                            else if (utils_1.isUndefined(_args)) {
                                args = {};
                            }
                            else {
                                args = _args;
                            }
                            if (utils_1.isUndefined(args.push)) {
                                args.push = true;
                            }
                            if (utils_1.isUndefined(args.with)) {
                                args.with = {};
                            }
                            fromCtx = this.ctx;
                            _a = Router.parseUrl(url), search = _a.search, hash = _a.hash;
                            path = Router.getPath(url);
                            route = this.resolveRoute(path);
                            _b = tslib_1.__read(route.parse(path), 3), pathname = _b[1], childPath = _b[2];
                            samePage = fromCtx.pathname === pathname;
                            if (!(fromCtx.$child && samePage && !args.force)) return [3 /*break*/, 2];
                            return [4 /*yield*/, fromCtx.$child.router.update(childPath + search + hash, args)];
                        case 1: return [2 /*return*/, _d.sent()];
                        case 2:
                            toCtx = new context_1.Context(this, this.ctx.$parent, path, args.with);
                            if (!toCtx.route) {
                                return [2 /*return*/, false];
                            }
                            return [4 /*yield*/, fromCtx.runBeforeNavigateCallbacks()];
                        case 3:
                            shouldNavigate = _d.sent();
                            if (shouldNavigate === false) {
                                return [2 /*return*/, false];
                            }
                            this.isNavigating(true);
                            return [4 /*yield*/, fromCtx.runBeforeDispose()];
                        case 4:
                            _d.sent();
                            history[args.push ? 'pushState' : 'replaceState'](history.state, document.title, toCtx.base + toCtx.path + search + hash);
                            return [4 /*yield*/, toCtx.runBeforeRender()];
                        case 5:
                            _d.sent();
                            if (utils_1.isUndefined(toCtx._redirect)) {
                                this.component(null);
                                ko.tasks.runEarly();
                            }
                            this.ctx = toCtx;
                            return [4 /*yield*/, fromCtx.runAfterDispose()];
                        case 6:
                            _d.sent();
                            toCtx.render();
                            if (!!utils_1.isUndefined(toCtx._redirect)) return [3 /*break*/, 8];
                            return [4 /*yield*/, toCtx.runAfterRender()];
                        case 7:
                            _d.sent();
                            _c = utils_1.traversePath(toCtx.router, toCtx._redirect), r = _c.router, p = _c.path;
                            r.update(p, toCtx._redirectArgs);
                            _d.label = 8;
                        case 8: return [2 /*return*/, true];
                    }
                });
            });
        };
        Router.prototype.resolveRoute = function (path) {
            var matchingRouteWithFewestDynamicSegments;
            var fewestMatchingSegments = Infinity;
            for (var rn in this.routes) {
                if (this.routes.hasOwnProperty(rn)) {
                    var r = this.routes[rn];
                    if (r.matches(path)) {
                        if (r.keys.length === 0) {
                            return r;
                        }
                        else if (fewestMatchingSegments === Infinity ||
                            (r.keys.length < fewestMatchingSegments && r.keys[0].pattern !== '.*')) {
                            fewestMatchingSegments = r.keys.length;
                            matchingRouteWithFewestDynamicSegments = r;
                        }
                    }
                }
            }
            return matchingRouteWithFewestDynamicSegments;
        };
        Router.prototype.dispose = function () {
            if (this.isRoot) {
                document.removeEventListener(Router.events.click, Router.onclick, false);
                window.removeEventListener(Router.events.popstate, Router.onpopstate, false);
                delete Router.head; // eslint-disable-line
                // this.ctx.runBeforeDispose().then(() => this.ctx.runAfterDispose())
            }
        };
        Object.defineProperty(Router, "initialized", {
            get: function () {
                var _this = this;
                if (Router.head) {
                    return Promise.resolve(Router.head);
                }
                else {
                    return new Promise(function (resolve) { return _this.onInit.push(resolve); });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Router, "base", {
            get: function () {
                return Router.config.base + (Router.config.hashbang ? '/#!' : '');
            },
            enumerable: true,
            configurable: true
        });
        Router.setConfig = function (_a) {
            var base = _a.base, hashbang = _a.hashbang, activePathCSSClass = _a.activePathCSSClass;
            utils_1.extendWith(Router.config, {
                base: base,
                hashbang: hashbang,
                activePathCSSClass: activePathCSSClass
            }, function (_default, v) { return utils_1.isUndefined(v) ? _default : v; });
        };
        Router.use = function () {
            var fns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fns[_i] = arguments[_i];
            }
            (_a = Router.middleware).push.apply(_a, tslib_1.__spread(fns));
            var _a;
        };
        Router.usePlugin = function () {
            var fns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fns[_i] = arguments[_i];
            }
            (_a = Router.plugins).push.apply(_a, tslib_1.__spread(fns));
            var _a;
        };
        Router.useRoutes = function (routes) {
            utils_1.extend(Router.routes, Router.normalizeRoutes(routes));
        };
        Router.get = function (i) {
            var router = Router.head;
            while (i-- > 0) {
                router = router.ctx.$child.router;
            }
            return router;
        };
        Router.update = function (url, _args) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Router.head.update(url, _args)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Router.getPathFromLocation = function () {
            var path = location.pathname + location.search + location.hash;
            var baseWithOrWithoutHashbangRegexp = Router.config.base.replace('#!', '#?!?');
            return path.replace(new RegExp(baseWithOrWithoutHashbangRegexp, 'i'), '');
        };
        Router.onclick = function (e) {
            if (e.defaultPrevented) {
                return;
            }
            var el = e.target;
            while (el && el.nodeName !== 'A') {
                el = el.parentNode;
            }
            if (!el || el.nodeName !== 'A') {
                return;
            }
            var pathname = el.pathname, search = el.search, _a = el.hash, hash = _a === void 0 ? '' : _a;
            var path = (pathname + search + hash).replace(new RegExp(Router.base, 'i'), '');
            var isValidRoute = Router.hasRoute(path);
            var isCrossOrigin = !Router.sameOrigin(el.href);
            var isDoubleClick = Router.which(e) !== 1;
            var isDownload = el.hasAttribute('download');
            var isEmptyHash = el.getAttribute('href') === '#';
            var isMailto = (el.getAttribute('href') || '').indexOf('mailto:') === 0;
            var hasExternalRel = el.getAttribute('rel') === 'external';
            var hasModifier = e.metaKey || e.ctrlKey || e.shiftKey;
            var hasOtherTarget = el.hasAttribute('target');
            if (!isValidRoute ||
                isCrossOrigin ||
                isDoubleClick ||
                isDownload ||
                isEmptyHash ||
                isMailto ||
                hasExternalRel ||
                hasModifier ||
                hasOtherTarget) {
                return;
            }
            Router.update(path);
            e.preventDefault();
        };
        Router.onpopstate = function (e) {
            Router.update(Router.getPathFromLocation(), false);
            e.preventDefault();
        };
        Router.canonicalizePath = function (path) {
            return path.replace(new RegExp('/?#?!?/?'), '/');
        };
        Router.parseUrl = function (url) {
            var parser = document.createElement('a');
            var b = Router.base.toLowerCase();
            if (b && url.toLowerCase().indexOf(b) === 0) {
                url = url.replace(new RegExp(b, 'i'), '') || '/';
            }
            parser.href = Router.canonicalizePath(url);
            return {
                hash: parser.hash,
                pathname: (parser.pathname.charAt(0) === '/')
                    ? parser.pathname
                    : '/' + parser.pathname,
                search: parser.search
            };
        };
        Router.getPath = function (url) {
            return Router.parseUrl(url).pathname;
        };
        Router.hasRoute = function (path) {
            return !utils_1.isUndefined(Router.head.resolveRoute(Router.getPath(path)));
        };
        Router.createRoutes = function (routes) {
            return utils_1.map(routes, function (config, path) { return new route_1.Route(path, config); });
        };
        Router.normalizeRoutes = function (routes) {
            return utils_1.mapValues(routes, function (c) {
                return utils_1.map(Router.runPlugins(c), function (routeConfig) {
                    return utils_1.isPlainObject(routeConfig)
                        ? Router.normalizeRoutes(routeConfig) // eslint-disable-line
                        : routeConfig;
                });
            });
        };
        Router.runPlugins = function (config) {
            return utils_1.flatMap(utils_1.castArray(config), function (rc) {
                var routeConfig = utils_1.reduce(Router.plugins, function (accum, plugin) {
                    var prc = plugin(rc);
                    return utils_1.isUndefined(prc) ? accum : accum.concat(utils_1.castArray(prc));
                }, []);
                return routeConfig.length > 0
                    ? routeConfig
                    : rc;
            });
        };
        Router.sameOrigin = function (href) {
            var hostname = location.hostname, port = location.port, protocol = location.protocol;
            var origin = protocol + '//' + hostname;
            if (port) {
                origin += ':' + port;
            }
            return href && href.indexOf(origin) === 0;
        };
        Router.which = function (e) {
            e = e || window.event;
            return e.which === null ? e.button : e.which;
        };
        /* eslint-disable */
        Router.routes = {};
        Router.events = {
            click: document.ontouchstart ? 'touchstart' : 'click',
            popstate: 'popstate'
        };
        Router.onInit = [];
        Router.middleware = [];
        Router.plugins = [];
        Router.config = {
            base: '',
            hashbang: false,
            activePathCSSClass: 'active-path'
        };
        return Router;
    }());
    exports.Router = Router;
});
//# sourceMappingURL=router.js.map