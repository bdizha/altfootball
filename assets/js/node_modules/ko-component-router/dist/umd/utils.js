(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "lodash-es/isFunction", "lodash-es/isUndefined", "lodash-es/noop", "lodash-es/startsWith", "lodash-es/isArray", "lodash-es/isBoolean", "lodash-es/isFunction", "lodash-es/isPlainObject", "lodash-es/isString", "lodash-es/isUndefined", "lodash-es/castArray", "lodash-es/concat", "lodash-es/extend", "lodash-es/extendWith", "lodash-es/filter", "lodash-es/flatMap", "lodash-es/map", "lodash-es/mapValues", "lodash-es/reduce"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var isFunction_1 = require("lodash-es/isFunction");
    var isUndefined_1 = require("lodash-es/isUndefined");
    var noop_1 = require("lodash-es/noop");
    var startsWith_1 = require("lodash-es/startsWith");
    var isArray_1 = require("lodash-es/isArray");
    exports.isArray = isArray_1.default;
    var isBoolean_1 = require("lodash-es/isBoolean");
    exports.isBoolean = isBoolean_1.default;
    var isFunction_2 = require("lodash-es/isFunction");
    exports.isFunction = isFunction_2.default;
    var isPlainObject_1 = require("lodash-es/isPlainObject");
    exports.isPlainObject = isPlainObject_1.default;
    var isString_1 = require("lodash-es/isString");
    exports.isString = isString_1.default;
    var isUndefined_2 = require("lodash-es/isUndefined");
    exports.isUndefined = isUndefined_2.default;
    var castArray_1 = require("lodash-es/castArray");
    exports.castArray = castArray_1.default;
    var concat_1 = require("lodash-es/concat");
    exports.concat = concat_1.default;
    var extend_1 = require("lodash-es/extend");
    exports.extend = extend_1.default;
    var extendWith_1 = require("lodash-es/extendWith");
    exports.extendWith = extendWith_1.default;
    var filter_1 = require("lodash-es/filter");
    exports.filter = filter_1.default;
    var flatMap_1 = require("lodash-es/flatMap");
    exports.flatMap = flatMap_1.default;
    var map_1 = require("lodash-es/map");
    exports.map = map_1.default;
    var mapValues_1 = require("lodash-es/mapValues");
    exports.mapValues = mapValues_1.default;
    var reduce_1 = require("lodash-es/reduce");
    exports.reduce = reduce_1.default;
    /* eslint-enable */
    function sequence(callbacks) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var count, success, callbacks_1, callbacks_1_1, _fn, ret, e_1_1, e_1, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        count = 0;
                        success = true;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        callbacks_1 = tslib_1.__values(callbacks), callbacks_1_1 = callbacks_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!callbacks_1_1.done) return [3 /*break*/, 5];
                        _fn = callbacks_1_1.value;
                        count++;
                        return [4 /*yield*/, promisify(_fn).apply(void 0, tslib_1.__spread(args))];
                    case 3:
                        ret = _b.sent();
                        if (ret === false) {
                            success = false;
                            return [3 /*break*/, 5];
                        }
                        _b.label = 4;
                    case 4:
                        callbacks_1_1 = callbacks_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, { count: count, success: success }];
                }
            });
        });
    }
    exports.sequence = sequence;
    function traversePath(router, path) {
        if (path.indexOf('//') === 0) {
            path = path.replace('//', '/');
            while (!router.isRoot) {
                router = router.ctx.$parent.router;
            }
        }
        else {
            if (path.indexOf('./') === 0) {
                path = path.replace('./', '/');
                router = router.ctx.$child.router;
            }
            while (path && path.match(/\/?\.\./i) && !router.isRoot) {
                router = router.ctx.$parent.router;
                path = path.replace(/\/?\.\./i, '');
            }
        }
        return { router: router, path: path };
    }
    exports.traversePath = traversePath;
    function resolveHref(_a) {
        var router = _a.router, path = _a.path;
        return router.ctx.base + path;
    }
    exports.resolveHref = resolveHref;
    function isActivePath(_a) {
        var router = _a.router, path = _a.path;
        var ctx = router.ctx;
        while (ctx) {
            // create dependency on isNavigating so that this works with nested routes
            // inside a computed
            ctx.router.isNavigating();
            if (ctx.$child ? startsWith_1.default(path, ctx.pathname) : path === ctx.pathname) {
                path = path.substr(ctx.pathname.length) || '/';
                ctx = ctx.$child;
            }
            else {
                return false;
            }
        }
        return true;
    }
    exports.isActivePath = isActivePath;
    function isGenerator(x) {
        return x.constructor.name === 'GeneratorFunction';
    }
    exports.isGenerator = isGenerator;
    function isThenable(x) {
        return !isUndefined_1.default(x) && isFunction_1.default(x.then);
    }
    exports.isThenable = isThenable;
    function promisify(_fn) {
        var _this = this;
        if (_fn === void 0) { _fn = noop_1.default; }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var fn, ret, _a;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            fn = function () {
                                return _fn.length === args.length + 1
                                    ? new Promise(function (r) {
                                        _fn.apply(void 0, tslib_1.__spread(args, [r]));
                                    })
                                    : _fn.apply(void 0, tslib_1.__spread(args));
                            };
                            ret = fn();
                            if (!isThenable(ret)) return [3 /*break*/, 2];
                            return [4 /*yield*/, ret];
                        case 1:
                            _a = _b.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            _a = ret;
                            _b.label = 3;
                        case 3: return [2 /*return*/, _a];
                    }
                });
            });
        };
    }
    exports.promisify = promisify;
});
//# sourceMappingURL=utils.js.map