import * as tslib_1 from "tslib";
import isFunction from 'lodash-es/isFunction';
import isUndefined from 'lodash-es/isUndefined';
import noop from 'lodash-es/noop';
import startsWith from 'lodash-es/startsWith';
export { default as isArray } from 'lodash-es/isArray';
export { default as isBoolean } from 'lodash-es/isBoolean';
export { default as isFunction } from 'lodash-es/isFunction';
export { default as isPlainObject } from 'lodash-es/isPlainObject';
export { default as isString } from 'lodash-es/isString';
export { default as isUndefined } from 'lodash-es/isUndefined';
export { default as castArray } from 'lodash-es/castArray';
export { default as concat } from 'lodash-es/concat';
export { default as extend } from 'lodash-es/extend';
export { default as extendWith } from 'lodash-es/extendWith';
export { default as filter } from 'lodash-es/filter';
export { default as flatMap } from 'lodash-es/flatMap';
export { default as map } from 'lodash-es/map';
export { default as mapValues } from 'lodash-es/mapValues';
export { default as reduce } from 'lodash-es/reduce';
/* eslint-enable */
export function sequence(callbacks) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var count, success, callbacks_1, callbacks_1_1, _fn, ret, e_1_1, e_1, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    count = 0;
                    success = true;
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 8]);
                    callbacks_1 = tslib_1.__values(callbacks), callbacks_1_1 = callbacks_1.next();
                    _b.label = 2;
                case 2:
                    if (!!callbacks_1_1.done) return [3 /*break*/, 5];
                    _fn = callbacks_1_1.value;
                    count++;
                    return [4 /*yield*/, promisify(_fn).apply(void 0, tslib_1.__spread(args))];
                case 3:
                    ret = _b.sent();
                    if (ret === false) {
                        success = false;
                        return [3 /*break*/, 5];
                    }
                    _b.label = 4;
                case 4:
                    callbacks_1_1 = callbacks_1.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/, { count: count, success: success }];
            }
        });
    });
}
export function traversePath(router, path) {
    if (path.indexOf('//') === 0) {
        path = path.replace('//', '/');
        while (!router.isRoot) {
            router = router.ctx.$parent.router;
        }
    }
    else {
        if (path.indexOf('./') === 0) {
            path = path.replace('./', '/');
            router = router.ctx.$child.router;
        }
        while (path && path.match(/\/?\.\./i) && !router.isRoot) {
            router = router.ctx.$parent.router;
            path = path.replace(/\/?\.\./i, '');
        }
    }
    return { router: router, path: path };
}
export function resolveHref(_a) {
    var router = _a.router, path = _a.path;
    return router.ctx.base + path;
}
export function isActivePath(_a) {
    var router = _a.router, path = _a.path;
    var ctx = router.ctx;
    while (ctx) {
        // create dependency on isNavigating so that this works with nested routes
        // inside a computed
        ctx.router.isNavigating();
        if (ctx.$child ? startsWith(path, ctx.pathname) : path === ctx.pathname) {
            path = path.substr(ctx.pathname.length) || '/';
            ctx = ctx.$child;
        }
        else {
            return false;
        }
    }
    return true;
}
export function isGenerator(x) {
    return x.constructor.name === 'GeneratorFunction';
}
export function isThenable(x) {
    return !isUndefined(x) && isFunction(x.then);
}
export function promisify(_fn) {
    var _this = this;
    if (_fn === void 0) { _fn = noop; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fn, ret, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        fn = function () {
                            return _fn.length === args.length + 1
                                ? new Promise(function (r) {
                                    _fn.apply(void 0, tslib_1.__spread(args, [r]));
                                })
                                : _fn.apply(void 0, tslib_1.__spread(args));
                        };
                        ret = fn();
                        if (!isThenable(ret)) return [3 /*break*/, 2];
                        return [4 /*yield*/, ret];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = ret;
                        _b.label = 3;
                    case 3: return [2 /*return*/, _a];
                }
            });
        });
    };
}
//# sourceMappingURL=utils.js.map