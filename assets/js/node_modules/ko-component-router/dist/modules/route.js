import * as tslib_1 from "tslib";
import pathtoRegexp from 'path-to-regexp';
import { isFunction, isPlainObject, isString, isUndefined, map, reduce } from './utils';
var Route = (function () {
    /* eslint-enable */
    function Route(path, config) {
        var _a = tslib_1.__read(Route.parseConfig(config), 3), component = _a[0], middleware = _a[1], children = _a[2];
        this.path = path;
        this.component = component;
        this.middleware = middleware;
        this.children = children;
        var _b = tslib_1.__read(Route.parsePath(path, !isUndefined(children)), 2), keys = _b[0], regexp = _b[1];
        this.keys = keys;
        this.regexp = regexp;
    }
    Route.prototype.matches = function (path) {
        var matches = this.regexp.exec(path);
        if (matches === null) {
            return false;
        }
        if (this.children) {
            try {
                for (var _a = tslib_1.__values(this.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var childRoute = _b.value;
                    var childPath = '/' + (matches[matches.length - 1] || '');
                    if (childRoute.matches(childPath)) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        }
        return true;
        var e_1, _c;
    };
    Route.prototype.parse = function (path) {
        var childPath;
        var params = {};
        var matches = this.regexp.exec(path);
        for (var i = 1, len = matches.length; i < len; ++i) {
            var k = this.keys[i - 1];
            var v = matches[i] || '';
            if (k.name === '__child_path__') {
                childPath = '/' + v;
                path = path.replace(new RegExp(childPath + '$'), '');
            }
            else {
                params[k.name] = v;
            }
        }
        return [params, path, childPath];
    };
    Route.parseConfig = function (config) {
        var component;
        var children;
        var middleware = reduce(config, function (accum, m) {
            if (isString(m)) {
                m = m;
                component = m;
            }
            else if (isPlainObject(m)) {
                m = m;
                children = map(m, function (routeConfig, path) { return new Route(path, routeConfig); });
                if (!component) {
                    component = 'ko-component-router';
                }
            }
            else if (isFunction(m)) {
                m = m;
                accum.push(m);
            }
            return accum;
        }, []);
        return [component, middleware, children];
    };
    Route.parsePath = function (path, hasChildren) {
        if (hasChildren) {
            path = path.replace(/\/?!?$/, '/!');
        }
        if (path[path.length - 1] === '!') {
            path = path.replace('!', ':__child_path__(.*)?');
        }
        else {
            path = path.replace(/\(?\*\)?/, '(.*)');
        }
        var keys = [];
        var regexp = pathtoRegexp(path, keys);
        return [keys, regexp];
    };
    return Route;
}());
export { Route };
//# sourceMappingURL=route.js.map