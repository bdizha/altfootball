import * as tslib_1 from "tslib";
import * as ko from 'knockout';
import { Context } from './context';
import { Route } from './route';
import { isBoolean, isPlainObject, isUndefined, castArray, extend, extendWith, flatMap, map, mapValues, reduce, traversePath } from './utils';
/* eslint-enable */
var Router = (function () {
    /* eslint-enable */
    function Router(url, $parentCtx, _with) {
        if (_with === void 0) { _with = {}; }
        this.onInit = [];
        this.component = ko.observable(null);
        this.isNavigating = ko.observable(true);
        this.isRoot = isUndefined($parentCtx);
        this.routes = this.isRoot
            ? Router.createRoutes(Router.routes)
            : $parentCtx.route.children;
        if (this.isRoot) {
            Router.head = this;
            document.addEventListener(Router.events.click, Router.onclick);
            window.addEventListener(Router.events.popstate, Router.onpopstate);
        }
        this.ctx = new Context(this, $parentCtx, Router.getPath(url), _with);
    }
    Object.defineProperty(Router.prototype, "initialized", {
        get: function () {
            var _this = this;
            if (this.isNavigating()) {
                return new Promise(function (resolve) { return _this.onInit.push(resolve); });
            }
            else {
                return Promise.resolve(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Router.prototype.init = function () {
        var _this = this;
        this.isNavigating(false);
        this.ctx.runAfterRender().then(function () {
            var resolveRouter = function (router) { return function (resolve) { return resolve(router); }; };
            var ctx = _this.ctx;
            while (ctx) {
                map(ctx.router.onInit, resolveRouter(ctx.router));
                ctx = ctx.$child;
            }
        });
    };
    Router.prototype.update = function (url, _args) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var args, fromCtx, _a, search, hash, path, route, _b, pathname, childPath, samePage, toCtx, shouldNavigate, _c, r, p;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (isBoolean(_args)) {
                            args = { push: _args };
                        }
                        else if (isUndefined(_args)) {
                            args = {};
                        }
                        else {
                            args = _args;
                        }
                        if (isUndefined(args.push)) {
                            args.push = true;
                        }
                        if (isUndefined(args.with)) {
                            args.with = {};
                        }
                        fromCtx = this.ctx;
                        _a = Router.parseUrl(url), search = _a.search, hash = _a.hash;
                        path = Router.getPath(url);
                        route = this.resolveRoute(path);
                        _b = tslib_1.__read(route.parse(path), 3), pathname = _b[1], childPath = _b[2];
                        samePage = fromCtx.pathname === pathname;
                        if (!(fromCtx.$child && samePage && !args.force)) return [3 /*break*/, 2];
                        return [4 /*yield*/, fromCtx.$child.router.update(childPath + search + hash, args)];
                    case 1: return [2 /*return*/, _d.sent()];
                    case 2:
                        toCtx = new Context(this, this.ctx.$parent, path, args.with);
                        if (!toCtx.route) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, fromCtx.runBeforeNavigateCallbacks()];
                    case 3:
                        shouldNavigate = _d.sent();
                        if (shouldNavigate === false) {
                            return [2 /*return*/, false];
                        }
                        this.isNavigating(true);
                        return [4 /*yield*/, fromCtx.runBeforeDispose()];
                    case 4:
                        _d.sent();
                        history[args.push ? 'pushState' : 'replaceState'](history.state, document.title, toCtx.base + toCtx.path + search + hash);
                        return [4 /*yield*/, toCtx.runBeforeRender()];
                    case 5:
                        _d.sent();
                        if (isUndefined(toCtx._redirect)) {
                            this.component(null);
                            ko.tasks.runEarly();
                        }
                        this.ctx = toCtx;
                        return [4 /*yield*/, fromCtx.runAfterDispose()];
                    case 6:
                        _d.sent();
                        toCtx.render();
                        if (!!isUndefined(toCtx._redirect)) return [3 /*break*/, 8];
                        return [4 /*yield*/, toCtx.runAfterRender()];
                    case 7:
                        _d.sent();
                        _c = traversePath(toCtx.router, toCtx._redirect), r = _c.router, p = _c.path;
                        r.update(p, toCtx._redirectArgs);
                        _d.label = 8;
                    case 8: return [2 /*return*/, true];
                }
            });
        });
    };
    Router.prototype.resolveRoute = function (path) {
        var matchingRouteWithFewestDynamicSegments;
        var fewestMatchingSegments = Infinity;
        for (var rn in this.routes) {
            if (this.routes.hasOwnProperty(rn)) {
                var r = this.routes[rn];
                if (r.matches(path)) {
                    if (r.keys.length === 0) {
                        return r;
                    }
                    else if (fewestMatchingSegments === Infinity ||
                        (r.keys.length < fewestMatchingSegments && r.keys[0].pattern !== '.*')) {
                        fewestMatchingSegments = r.keys.length;
                        matchingRouteWithFewestDynamicSegments = r;
                    }
                }
            }
        }
        return matchingRouteWithFewestDynamicSegments;
    };
    Router.prototype.dispose = function () {
        if (this.isRoot) {
            document.removeEventListener(Router.events.click, Router.onclick, false);
            window.removeEventListener(Router.events.popstate, Router.onpopstate, false);
            delete Router.head; // eslint-disable-line
            // this.ctx.runBeforeDispose().then(() => this.ctx.runAfterDispose())
        }
    };
    Object.defineProperty(Router, "initialized", {
        get: function () {
            var _this = this;
            if (Router.head) {
                return Promise.resolve(Router.head);
            }
            else {
                return new Promise(function (resolve) { return _this.onInit.push(resolve); });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Router, "base", {
        get: function () {
            return Router.config.base + (Router.config.hashbang ? '/#!' : '');
        },
        enumerable: true,
        configurable: true
    });
    Router.setConfig = function (_a) {
        var base = _a.base, hashbang = _a.hashbang, activePathCSSClass = _a.activePathCSSClass;
        extendWith(Router.config, {
            base: base,
            hashbang: hashbang,
            activePathCSSClass: activePathCSSClass
        }, function (_default, v) { return isUndefined(v) ? _default : v; });
    };
    Router.use = function () {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        (_a = Router.middleware).push.apply(_a, tslib_1.__spread(fns));
        var _a;
    };
    Router.usePlugin = function () {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        (_a = Router.plugins).push.apply(_a, tslib_1.__spread(fns));
        var _a;
    };
    Router.useRoutes = function (routes) {
        extend(Router.routes, Router.normalizeRoutes(routes));
    };
    Router.get = function (i) {
        var router = Router.head;
        while (i-- > 0) {
            router = router.ctx.$child.router;
        }
        return router;
    };
    Router.update = function (url, _args) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Router.head.update(url, _args)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Router.getPathFromLocation = function () {
        var path = location.pathname + location.search + location.hash;
        var baseWithOrWithoutHashbangRegexp = Router.config.base.replace('#!', '#?!?');
        return path.replace(new RegExp(baseWithOrWithoutHashbangRegexp, 'i'), '');
    };
    Router.onclick = function (e) {
        if (e.defaultPrevented) {
            return;
        }
        var el = e.target;
        while (el && el.nodeName !== 'A') {
            el = el.parentNode;
        }
        if (!el || el.nodeName !== 'A') {
            return;
        }
        var pathname = el.pathname, search = el.search, _a = el.hash, hash = _a === void 0 ? '' : _a;
        var path = (pathname + search + hash).replace(new RegExp(Router.base, 'i'), '');
        var isValidRoute = Router.hasRoute(path);
        var isCrossOrigin = !Router.sameOrigin(el.href);
        var isDoubleClick = Router.which(e) !== 1;
        var isDownload = el.hasAttribute('download');
        var isEmptyHash = el.getAttribute('href') === '#';
        var isMailto = (el.getAttribute('href') || '').indexOf('mailto:') === 0;
        var hasExternalRel = el.getAttribute('rel') === 'external';
        var hasModifier = e.metaKey || e.ctrlKey || e.shiftKey;
        var hasOtherTarget = el.hasAttribute('target');
        if (!isValidRoute ||
            isCrossOrigin ||
            isDoubleClick ||
            isDownload ||
            isEmptyHash ||
            isMailto ||
            hasExternalRel ||
            hasModifier ||
            hasOtherTarget) {
            return;
        }
        Router.update(path);
        e.preventDefault();
    };
    Router.onpopstate = function (e) {
        Router.update(Router.getPathFromLocation(), false);
        e.preventDefault();
    };
    Router.canonicalizePath = function (path) {
        return path.replace(new RegExp('/?#?!?/?'), '/');
    };
    Router.parseUrl = function (url) {
        var parser = document.createElement('a');
        var b = Router.base.toLowerCase();
        if (b && url.toLowerCase().indexOf(b) === 0) {
            url = url.replace(new RegExp(b, 'i'), '') || '/';
        }
        parser.href = Router.canonicalizePath(url);
        return {
            hash: parser.hash,
            pathname: (parser.pathname.charAt(0) === '/')
                ? parser.pathname
                : '/' + parser.pathname,
            search: parser.search
        };
    };
    Router.getPath = function (url) {
        return Router.parseUrl(url).pathname;
    };
    Router.hasRoute = function (path) {
        return !isUndefined(Router.head.resolveRoute(Router.getPath(path)));
    };
    Router.createRoutes = function (routes) {
        return map(routes, function (config, path) { return new Route(path, config); });
    };
    Router.normalizeRoutes = function (routes) {
        return mapValues(routes, function (c) {
            return map(Router.runPlugins(c), function (routeConfig) {
                return isPlainObject(routeConfig)
                    ? Router.normalizeRoutes(routeConfig) // eslint-disable-line
                    : routeConfig;
            });
        });
    };
    Router.runPlugins = function (config) {
        return flatMap(castArray(config), function (rc) {
            var routeConfig = reduce(Router.plugins, function (accum, plugin) {
                var prc = plugin(rc);
                return isUndefined(prc) ? accum : accum.concat(castArray(prc));
            }, []);
            return routeConfig.length > 0
                ? routeConfig
                : rc;
        });
    };
    Router.sameOrigin = function (href) {
        var hostname = location.hostname, port = location.port, protocol = location.protocol;
        var origin = protocol + '//' + hostname;
        if (port) {
            origin += ':' + port;
        }
        return href && href.indexOf(origin) === 0;
    };
    Router.which = function (e) {
        e = e || window.event;
        return e.which === null ? e.button : e.which;
    };
    /* eslint-disable */
    Router.routes = {};
    Router.events = {
        click: document.ontouchstart ? 'touchstart' : 'click',
        popstate: 'popstate'
    };
    Router.onInit = [];
    Router.middleware = [];
    Router.plugins = [];
    Router.config = {
        base: '',
        hashbang: false,
        activePathCSSClass: 'active-path'
    };
    return Router;
}());
export { Router };
//# sourceMappingURL=router.js.map