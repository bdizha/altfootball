/// <reference types="knockout" />
import { Context } from './context';
import { Route, RouteConfig } from './route';
import { AsyncCallback } from './utils';
export interface Middleware {
    (ctx: Context, done?: () => any): {
        beforeRender?: AsyncCallback;
        afterRender?: AsyncCallback;
        beforeDispose?: AsyncCallback;
        afterDispose?: AsyncCallback;
    };
}
export interface Plugin {
    (routeConfig: any): RouteConfig;
}
export interface RouteMap {
    [name: string]: Array<RouteConfig>;
}
export declare class Router {
    private static routes;
    private static events;
    static head: Router;
    static onInit: Array<Function>;
    static middleware: Array<Middleware>;
    static plugins: Array<Plugin>;
    static config: {
        base?: string;
        hashbang?: boolean;
        activePathCSSClass?: string;
    };
    onInit: Array<Function>;
    component: KnockoutObservable<string>;
    isNavigating: KnockoutObservable<boolean>;
    routes: Array<Route>;
    isRoot: boolean;
    ctx: Context;
    bound: boolean;
    constructor(url: string, $parentCtx?: Context, _with?: {
        [k: string]: any;
    });
    readonly initialized: Promise<Router>;
    init(): void;
    update(url: string, _args?: boolean | {
        push?: boolean;
        force?: boolean;
        with?: {
            [prop: string]: any;
        };
    }): Promise<boolean>;
    resolveRoute(path: string): Route;
    dispose(): void;
    static readonly initialized: Promise<Router>;
    static readonly base: string;
    static setConfig({base, hashbang, activePathCSSClass}: {
        base?: string;
        hashbang?: boolean;
        activePathCSSClass?: string;
    }): void;
    static use(...fns: Array<Middleware>): void;
    static usePlugin(...fns: Array<Plugin>): void;
    static useRoutes(routes: {
        [route: string]: any;
    }): void;
    static get(i: number): Router;
    static update(url: string, _args?: boolean | {
        push?: boolean;
        force?: boolean;
        with?: {
            [prop: string]: any;
        };
    }): Promise<boolean>;
    static getPathFromLocation(): string;
    private static onclick(e);
    private static onpopstate(e);
    private static canonicalizePath(path);
    private static parseUrl(url);
    private static getPath(url);
    private static hasRoute(path);
    private static createRoutes(routes);
    private static normalizeRoutes(routes);
    private static runPlugins(config);
    private static sameOrigin(href);
    private static which(e);
}
